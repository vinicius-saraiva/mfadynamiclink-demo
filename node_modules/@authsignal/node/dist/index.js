'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var axios = require('axios');

function _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }

var axios__default = /*#__PURE__*/_interopDefaultLegacy(axios);

const DEFAULT_API_BASE_URL = "https://api.authsignal.com/v1";
class Authsignal {
    constructor({ secret, apiBaseUrl, redirectUrl }) {
        this.secret = secret;
        this.apiBaseUrl = apiBaseUrl !== null && apiBaseUrl !== void 0 ? apiBaseUrl : DEFAULT_API_BASE_URL;
        this.redirectUrl = redirectUrl;
    }
    async getUser(request) {
        const { userId } = request;
        const url = `${this.apiBaseUrl}/users/${userId}`;
        const config = this.getBasicAuthConfig();
        const response = await axios__default["default"].get(url, config);
        return response.data;
    }
    async updateUser(request) {
        const { userId, ...data } = request;
        const url = `${this.apiBaseUrl}/users/${userId}`;
        const config = this.getBasicAuthConfig();
        const response = await axios__default["default"].post(url, data, config);
        return response.data;
    }
    async getAuthenticators(request) {
        const { userId } = request;
        const url = `${this.apiBaseUrl}/users/${userId}/authenticators`;
        const config = this.getBasicAuthConfig();
        const response = await axios__default["default"].get(url, config);
        return response.data;
    }
    async getChallenge(request) {
        const { userId, action, verificationMethod } = request;
        const url = new URL(`${this.apiBaseUrl}/users/${userId}/challenge`);
        if (action) {
            url.searchParams.set("action", action);
        }
        if (verificationMethod) {
            url.searchParams.set("verificationMethod", verificationMethod);
        }
        const config = this.getBasicAuthConfig();
        const response = await axios__default["default"].get(url.toString(), config);
        return response.data;
    }
    async track(request) {
        const { userId, action, redirectUrl = this.redirectUrl, ...rest } = request;
        const url = `${this.apiBaseUrl}/users/${userId}/actions/${action}`;
        const data = { redirectUrl, ...rest };
        const config = this.getBasicAuthConfig();
        const response = await axios__default["default"].post(url, data, config);
        return response.data;
    }
    async getAction(request) {
        var _a;
        const { userId, action, idempotencyKey } = request;
        const url = `${this.apiBaseUrl}/users/${userId}/actions/${action}/${idempotencyKey}`;
        const config = this.getBasicAuthConfig();
        try {
            const response = await axios__default["default"].get(url, config);
            return response.data;
        }
        catch (err) {
            if (axios__default["default"].isAxiosError(err) && ((_a = err.response) === null || _a === void 0 ? void 0 : _a.status) === 404) {
                return undefined;
            }
            else {
                throw err;
            }
        }
    }
    async enrollVerifiedAuthenticator(request) {
        const { userId, ...data } = request;
        const url = `${this.apiBaseUrl}/users/${userId}/authenticators`;
        const config = this.getBasicAuthConfig();
        const response = await axios__default["default"].post(url, data, config);
        return response.data;
    }
    async deleteAuthenticator(request) {
        const { userId, userAuthenticatorId } = request;
        const url = `${this.apiBaseUrl}/users/${userId}/authenticators/${userAuthenticatorId}`;
        const config = this.getBasicAuthConfig();
        const response = await axios__default["default"].delete(url, config);
        return response.data;
    }
    async validateChallenge(request) {
        const url = `${this.apiBaseUrl}/validate`;
        const config = this.getBasicAuthConfig();
        const response = await axios__default["default"].post(url, request, config);
        const { actionCode: action, ...rest } = response.data;
        return { action, ...rest };
    }
    getBasicAuthConfig() {
        return {
            auth: {
                username: this.secret,
                password: "",
            },
        };
    }
}

exports.UserActionState = void 0;
(function (UserActionState) {
    UserActionState["ALLOW"] = "ALLOW";
    UserActionState["BLOCK"] = "BLOCK";
    UserActionState["CHALLENGE_REQUIRED"] = "CHALLENGE_REQUIRED";
    UserActionState["CHALLENGE_SUCCEEDED"] = "CHALLENGE_SUCCEEDED";
    UserActionState["CHALLENGE_FAILED"] = "CHALLENGE_FAILED";
})(exports.UserActionState || (exports.UserActionState = {}));
exports.VerificationMethod = void 0;
(function (VerificationMethod) {
    VerificationMethod["SMS"] = "SMS";
    VerificationMethod["EMAIL_OTP"] = "EMAIL_OTP";
    VerificationMethod["EMAIL_MAGIC_LINK"] = "EMAIL_MAGIC_LINK";
    VerificationMethod["AUTHENTICATOR_APP"] = "AUTHENTICATOR_APP";
    VerificationMethod["PASSKEY"] = "PASSKEY";
    VerificationMethod["SECURITY_KEY"] = "SECURITY_KEY";
    VerificationMethod["PUSH"] = "PUSH";
    VerificationMethod["VERIFF"] = "VERIFF";
    VerificationMethod["IPROOV"] = "IPROOV";
    VerificationMethod["RECOVERY_CODE"] = "RECOVERY_CODE";
})(exports.VerificationMethod || (exports.VerificationMethod = {}));

const DEFAULT_ACTION_NAME = "auth0-login";
// eslint-disable-next-line @typescript-eslint/no-explicit-any
async function handleAuth0ExecutePostLogin(event, api, options) {
    var _a, _b, _c;
    // Redirects are not possible for refresh token exchange
    // https://auth0.com/docs/customize/actions/flows-and-triggers/login-flow/redirect-with-actions#refresh-tokens
    if (((_a = event.transaction) === null || _a === void 0 ? void 0 : _a.protocol) === "oauth2-refresh-token") {
        return;
    }
    const { secret = event.secrets.AUTHSIGNAL_SECRET, userId = event.user.user_id, action = DEFAULT_ACTION_NAME, redirectUrl = `https://${event.request.hostname}/continue`, custom = {}, apiBaseUrl = DEFAULT_API_BASE_URL, forceEnrollment = false, } = options !== null && options !== void 0 ? options : {};
    const sessionMfaMethod = (_b = event.authentication) === null || _b === void 0 ? void 0 : _b.methods.find(({ name }) => name === apiBaseUrl);
    // If user has already completed MFA for the current Auth0 session, don't prompt again
    if (sessionMfaMethod) {
        return;
    }
    const authsignal = new Authsignal({ secret, apiBaseUrl });
    const result = await authsignal.track({
        action,
        userId,
        redirectUrl,
        custom,
        email: event.user.email,
        ipAddress: event.request.ip,
        userAgent: event.request.user_agent,
        deviceId: (_c = event.request.query) === null || _c === void 0 ? void 0 : _c["device_id"],
    });
    const { isEnrolled, state, url } = result;
    const challengeUrl = forceEnrollment ? `${url}&force_enrollment=true` : url;
    if (!isEnrolled || state === exports.UserActionState.CHALLENGE_REQUIRED) {
        api.redirect.sendUserTo(challengeUrl);
    }
    else if (state === exports.UserActionState.BLOCK) {
        api.access.deny("Action blocked");
    }
}
// eslint-disable-next-line @typescript-eslint/no-explicit-any
async function handleAuth0ContinuePostLogin(event, api, options) {
    var _a;
    const { secret = event.secrets.AUTHSIGNAL_SECRET, userId = event.user.user_id, action = DEFAULT_ACTION_NAME, failureMessage = "MFA challenge failed", apiBaseUrl = DEFAULT_API_BASE_URL, } = options !== null && options !== void 0 ? options : {};
    const authsignal = new Authsignal({ secret, apiBaseUrl });
    const result = await authsignal.validateChallenge({
        token: (_a = event.request.query) === null || _a === void 0 ? void 0 : _a["token"],
        action,
        userId,
    });
    if (result.action !== action || result.state !== exports.UserActionState.CHALLENGE_SUCCEEDED) {
        api.access.deny(failureMessage);
    }
    else {
        api.authentication.recordMethod(apiBaseUrl);
    }
}

exports.Authsignal = Authsignal;
exports.DEFAULT_API_BASE_URL = DEFAULT_API_BASE_URL;
exports.handleAuth0ContinuePostLogin = handleAuth0ContinuePostLogin;
exports.handleAuth0ExecutePostLogin = handleAuth0ExecutePostLogin;
